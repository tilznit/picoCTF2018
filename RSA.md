# RSA problem solves for picoctf2018

Here are my walkthroughs of three RSA problems from picoctf2018.

First, you need to understand the [RSA cryptosystem](https://en.wikipedia.org/wiki/RSA_(cryptosystem)). Pay particular attention to the key generation section and the equations. You'll basically be using online tools to solve for the unknown parts of the equation, and use that info to grab the flag. 

## Safe RSA

You are given N,e,c

```python
N =  374159235470172130988938196520880526947952521620932362050308663243595788308583992120881359365258949723819911758198013202644666489247987314025169670926273213367237020188587742716017314320191350666762541039238241984934473188656610615918474673963331992408750047451253205158436452814354564283003696666945950908549197175404580533132142111356931324330631843602412540295482841975783884766801266552337129105407869020730226041538750535628619717708838029286366761470986056335230171148734027536820544543251801093230809186222940806718221638845816521738601843083746103374974120575519418797642878012234163709518203946599836959811`

e = 3

c = 2205316413931134031046440767620541984801091216351222789180582564557328762455422721368029531360076729972211412236072921577317264715424950823091382203435489460522094689149595951010342662368347987862878338851038892082799389023900415351164773

#c = the ciphertext
```

Googling for `RSA e=3` we can see that this is bad because if the plaintext message is smaller than 3^√N (cubed root of N) then a simple computation of 3^√C will recover the original message.

The problem here is that `type(c)=long`, and we encounter the [floating point error problem](https://en.wikipedia.org/wiki/Floating_point_error_mitigation) which reduces the accuracy of our calculation. I found a cubed root calculator that handles long types online at [https://www.dcode.fr/cube-root](https://www.dcode.fr/cube-root).



From the hints in Pizza it was mentioned that you have to convert it to hex, then plaintext:
hex(13016382529449106065839070830454998857466392684017754632233906857023684751222397)
'0x7069636f4354467b655f7734795f7430305f736d3431315f38316236353539667dL'
picoCTF{e_w4y_t00_sm411_81b6559f}

----------------------------------

## Supersafe RSA:

Given c, n, and e get the flag.

c: 7686966029791874563175059394981000840074736771341506547944950743609250244624246
n: 14568468476432837846531823758196941722524462577948878352231306047102565364099933
e: 65537

1. find p & q  (to get d) - https://www.alpertron.com.ar/ECM.HTM
p: 103419850061766398711688540905436955187
q: 140867236490209335558539611454420246899759

2. find d

https://www.dcode.fr/lcm

lcm(p-1,q-1) = 7284234238216418923265911879098470861191745960804303625137027373553619840122494

use modular inverse calc - https://www.dcode.fr/modular-inverse

d = 1/(65537 mod 7284234238216418923265911879098470861191745960804303625137027373553619840122494) = 3822119520023592992252745436904927231558688376033971543726629191475988816426329

3. python ---> m = hex(pow(c, d, n)).rstrip("L")

m = '0x7069636f4354467b7573335f6c40726733725f7072316d33245f313539397d'

4. Decode hex in cryptii

picoCTF{us3_l@rg3r_pr1m3$_1599}



Supersafe rsa 2: d and e are inverse; what vulns are present when d is small? Wiener Attack.
Given 
c: 33538497995588604996408152117996972621953696640861613118134969889521796779470201586945282006752313209689461633070764531554007793003259003113696492091456566880088643881435941452375339597035502224849198049869554524694812191167571253644179892127798064426824785323248346564905387800002957866428340488446476979594
n: 63120131701742542631724957494679420148151586570934815288349232630271727304242009721612488046773174196932845429956821213827698968828977521387447064786794208725793066207721790578020847445810506678306266767555353160751638816648909663976347413799940711345941628715313434845537627263422696019555484853655016282853
e: 52146318731822428333757791379441046204149890164489123764546630182962328630141372543101834693630162664518288144317746783958269454953802126134558286597668461757547144988283882073767372002785124265125110492425949756547249611589508775885381818549535047174287981914178170971177781513129479762394812965699621809025

Found wiener.py code online. Ran it and got p and q. Confirmed d from modular inverse calc - https://www.dcode.fr/modular-inverse

p =  7170786058747714673741069762247853387883334331414573762929369366243199754285681902253853367399436099128225124214046581910160575068405605073810198024428357
q =  8802400627298265787773757463511930694530274663935769402705851047894455718800247416582987762784479494875299315150449361526403662752095636522686087505226529 

lcm(p-1,q-1) = 15780032925435635657931239373669855037037896642733703822087308157567931826060502430403122011693293549233211357489205303456924742207244380346861766196698548188151595040435332265798405421506606066174317854303046881382806169748359144511757144239702631857586906297718517587398547674796218879578472089342371656992

!!! d = 65537 !!

m = hex(pow(c, d, n)).rstrip("L") = '0x7069636f4354467b77407463685f793075725f5870306e336e74245f6340723366753131795f353638393635327d'
picoCTF{w@tch_y0ur_Xp0n3nt$_c@r3fu11y_5689652}
